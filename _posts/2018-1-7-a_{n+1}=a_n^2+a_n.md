---
layout: post
tags: mathematica
title: 二次非线性差分方程通项公式
---

有好一段时间没有写博客了，终于开始让自己忙起来了，大学生活也貌似终于步入了正规。复分析学习笔记（二）也竟然一直拖到现在。最近一定要更新了。

这次博客记录的内容是一个困扰了我很久的问题：数列\\(a_{n+1}=a_n^2+a_n\\)的通项公式。这个问题来自高三一次数学考试，那道题并不需要解出这个数列的通项公式，但是我一直试图将它解出来。最终感觉这个数列没有初等的通项公式，于是又开始寻找非初等的通项公式，也依旧无果。

最终前几天苏神给了我一个十分好的思路（见他的博文[《特殊的通项公式：二次非线性递推》](http://spaces.ac.cn/archives/3064/)）

解数学问题时条件的运用往往至关重要，而有些条件往往是隐藏的，有时善于利用这些隐藏条件可以起到十分巧妙的作用。

比如接下来讨论的问题：
\\[a_{n+1}=a_n^2+a_n,a_0=1\\]
求\\(a_n\\)通项公式。

这个数列有一个隐藏条件：**所有的项都是正整数**。

这个隐藏条件几乎不怎么用到，但是如果配合取整函数，就可以有大作用了。苏神给出的思路如下：

```
找一个近似数列，使得其误差与目标数列在0.5以内，然后对其四舍五入取整，就可以得到精确的解
```

# 解

### 变形

在不断的尝试之中，得到一种换元方法可以简化形式：
\\[c_n=a_n+\frac{1}{2}\\]
可以得到
\\[c_{n+1}=c_n^2+\frac{1}{4}\\]
这就和苏神文章中形式类似了。但是注意到\\(c_n\\)并非整数数列（小数部分一定是0.5），所以需要对原算法做一些改动。

从形式上看，原先数列中的一项换成了一个常数\\(\frac{1}{4}\\)，这表明了原先数列的增长有多快，所以可以用忽略一次项来近似，于是先考虑数列：\\(b_{n+1}=b_n^2\\)，这个数列的解法很经典，对两边取对数得：\\(\ln b_{n+1}=2\ln b_n\\)，于是\\(\ln b_n\\)是一个等比数列。解得\\(b_n=(b_0)^{2^n}\\)

于是现在不妨用\\(k^{2^n}\\)来拟合原数列。

### 寻找近似解

\\[
\begin{eqnarray}
\nonumber \ln c_{n+1}&=& \ln (c_n^2+\frac{1}{4}) \\\
\nonumber &=& \ln (c_n^2(1+\frac{1}{4c_n^2})) \\\
\nonumber &=& 2\ln c_n + \ln(1+\frac{1}{4c_n^2})
\end{eqnarray}
\\]

设 \\(x_n=\ln c_n\\)

\\[
\begin{eqnarray}
\nonumber x_{n}&=&\ln c_{n} \\\
\nonumber &=&2x_{n-1}+\ln(1+\frac{1}{4c_{n-1}^2}) \\\
\nonumber &=&2x_{n-2}+2\ln(1+\frac{1}{4c_{n-2}^2})+\ln(1+\frac{1}{4c_{n-1}^2}) \\\
\nonumber &=& \cdots \\\
\nonumber &=&2^ix_{n-i}+\sum_{j=n-i}^{n-1}2^{n-j-1}\ln(1+\frac{1}{4c_j^2}) \\\
\nonumber (取i=n)&=&2^nx_0+\sum_{j=0}^{n-1}2^{n-j-1}\ln(1+\frac{1}{4c_j^2}) \\\
\nonumber &=&2^nx_0+\sum_{j=0}^\infty2^{n-j-1}\ln(1+\frac{1}{4c_j^2})-\sum_{j=n}^\infty2^{n-j-1}\ln(1+\frac{1}{4c_j^2}) \\\
\nonumber &=& 2^n(x_0+\sum_{j=0}^\infty\frac{1}{2^{j+1}}\ln(1+\frac{1}{4c_j^2}))-2^{n-1}\sum_{j=n}^\infty\frac{1}{2^j}\ln(1+\frac{1}{4c_j^2}) \\\
\nonumber &=&\alpha \cdot 2^n-\beta
\end{eqnarray}
\\]

其中
\\[\alpha=x_0+\sum_{j=0}^\infty\frac{1}{2^{j+1}}\ln(1+\frac{1}{4c_j^2})\\]
\\[\beta=2^{n-1}\sum_{j=n}^\infty\frac{1}{2^j}\ln(1+\frac{1}{4c_j^2})\\]

此时我们得到了一个与\\(n\\)无关的常数\\(\alpha\\)和一个与\\(n\\)相关的数\\(\beta\\)

\\[x_n=\ln c_n=2^n\cdot\alpha-\beta\\]
\\[c_n=e^{-\beta}(e^\alpha)^{2^n}\\]

记\\(k=e^\alpha\\)并将\\(\hat{c}_n=k^{2^n}\\)作为我们的近似数列，将其与原数列\\(c_n=e^{-\beta}\hat{c}_n\\)比较从而判断误差范围。

由此可看出误差全部来自于\\(e^{-\beta}\\)，下面来判断\\(\beta\\)的范围。

从定义式出发：
\\[\beta=2^{n-1}\sum_{j=n}^\infty\frac{1}{2^j}\ln(1+\frac{1}{4c_j^2})\\]

注意到\\(c_0=a_0+\frac{1}{2}=\frac{2}{3}\\)，所以\\(c_n\\)是单增数列。可以做如下放缩：
 \\[j>n,\ln(1+\frac{1}{4c_j^2})<\ln(1+\frac{1}{4c_n^2})\\]
\\[0<\beta<\ln(1+\frac{1}{4c_n^2})\cdot 2^{n-1}\sum_{j=n}^\infty2^j=\ln(1+\frac{1}{4c_n^2})\\]
（这是由于\\(2^{n-1}\sum_{j=n}^\infty2^j=1\\)。此外，令上式\\(n\rightarrow\infty\\)，由夹逼定理\\(\beta\rightarrow 0\\)，即项数无穷大时没有误差）
\\[\frac{4c_n^2}{4c_n^2+1}=e^{-\ln(1+\frac{1}{4c_n^2})}< e^{-\beta}<1\\]

\\[\frac{4c_n^2\cdot\hat{c}_n}{4c_n^2+1}< c_n=e^{-\beta}\hat{c}_n<\hat{c}_n\\]
\\[c_n< \hat{c}_n<\frac{4c_n^2+1}{4c_n}=c_n+\frac{1}{4c_n}\\]
\\[0<\hat{c}_n-c_n<\frac{1}{4c_n}\le\frac{1}{4c_0}=\frac{1}{6}\\]

取\\(\hat{a}_n=\hat{c}_n\\)
\\[0<\hat{a}_n-a_n-\frac{1}{2}<\frac{1}{6}\\]
\\[\frac{1}{2}<\hat{a}_n-a_n<\frac{1}{3}\\]

也就是说\\(\hat{a}_n\\)总是比\\(a_n\\)大\\(\frac{1}{2}\\)到\\(\frac{1}{3}\\)，那么只需要对\\(\hat{a}_n=k^{2^n}\\)向下取整就可以得到\\(a_n\\)了。

即：
\\[a_n=\lfloor k^{2^n} \rfloor\\]

这就是我们的精确通项公式了。但是问题还没有结束：我们还没有算出\\(k\\)是多少。

### k的求解

\\(k=e^\alpha\\)，我们回到\\(\alpha\\)的定义式：
\\[\alpha=x_0+\sum_{j=0}^\infty\frac{1}{2^{j+1}}\ln(1+\frac{1}{4c_j^2})\\]

理论上需要所有的\\(c_j\\)才能知道\\(\alpha\\)，但是注意到\\(c_j\\)的增长很快，所以后面的项会很小，只需要求出前几项和就已经很精确了。

下面用计算机计算。由于数列增长很大，C++的long long int 都不足够，需要用高精度处理。。。所以只好用Python求值：

```
#Python
from math import exp, log

n=10
A=[1]
C=[1.5]
X=[log(1.5)]

for i in range(n):
  a=A[i]**2+A[i]
  A=A+[a]
  C=C+[a+0.5]
  X=X+[log(a+0.5)]

print("A:",A)
print("C:",C)
print("X:",X)

print("---------")

alpha=X[0]
for i in range(n):
  alpha=alpha+log(1+(1/(4*(C[i]**2))))/(2**(i+1))
  print("alpha:",alpha)

k=exp(alpha)

print("---------")

for i in range(n):
  print("a",i,":",k**(2**i))
  
print("Final Result: k=",k)
```

```
Output:
A: [1, 2, 6, 42, 1806, 3263442, 10650056950806, 113423713055421844361000442, 12864938683278671740537145998360961546653259485195806, 165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185442, 27392450308603031423410234291674686281194364367580914627947367941608692026226993634332118404582438634929548737283992369758487974306317730580753883429460344956410077034761330476016739454649828385541500213920806]
C: [1.5, 2.5, 6.5, 42.5, 1806.5, 3263442.5, 10650056950806.5, 1.1342371305542185e+26, 1.2864938683278672e+52, 1.6550664732451996e+104, 2.739245030860303e+208]
X: [0.4054651081081644, 0.9162907318741551, 1.8718021769015913, 3.7495040759303713, 7.499146550587695, 14.998293177781614, 29.996586355563252, 59.993172711126505, 119.98634542225301, 239.97269084450602, 479.94538168901204]
---------
alpha: 0.45814536593707755
alpha: 0.4679505442253979
alpha: 0.4686880094912964
alpha: 0.46869665941173094
alpha: 0.4686966618056755
alpha: 0.4686966618056759
alpha: 0.4686966618056759
alpha: 0.4686966618056759
alpha: 0.4686966618056759
alpha: 0.4686966618056759
---------
a 0 : 1.5979102180318732
a 1 : 2.5533170648906682
a 2 : 6.519428033861898
a 3 : 42.50294188870441
a 4 : 1806.500069194584
a 5 : 3263442.5000000373
a 6 : 10650056950806.494
a 7 : 1.134237130554217e+26
a 8 : 1.2864938683278643e+52
a 9 : 1.655066473245192e+104
Final Result: k= 1.5979102180318732
```

可以看出对最后的数列取整就是正确答案了，而\\(k=1.5979102180318732...\\)

# EOF

存疑很久的问题终于解决了，而且了解到了如此神奇的新思路。苏神提示说对有理数数列分母可以采用类似的方法，后面有时间再继续向下钻研吧~
